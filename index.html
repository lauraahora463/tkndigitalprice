<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Trading TKN y Análisis Técnico</title>
    
    <!-- Tailwind CSS y Fuente Inter -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Estilos Base: Fondo oscuro y fuente */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; 
            color: #e6e6e6;
            min-height: 100vh;
        }

        /* Contenedor de la gráfica y Card de Contenido */
        #chartContainer {
            height: 60vh;
            max-width: 1200px;
            margin: 0 auto;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background-color: #161b22;
        }
        #cryptoChart { display: block; background-color: transparent; }
        
        .content-card {
            background-color: #161b22;
            border: 1px solid #2d333b;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Necesario para el efecto de despliegue */
        }

        /* Estilo para el input y el botón de despliegue del acordeón */
        .accordion-content {
            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease-in-out, opacity 0.4s ease-in-out, padding 0.5s;
            overflow: hidden;
            padding-top: 0;
        }
        .accordion-content.open {
            max-height: 500px; /* Suficientemente grande para el contenido */
            opacity: 1;
            padding-top: 1rem;
        }

        /* Estilo para los formularios y botones de Auth */
        .auth-input {
            background-color: #2d333b;
            border: 1px solid #484f58;
            color: #e6e6e6;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            transition: border-color 0.2s;
        }
        .auth-input:focus {
            border-color: #38bdf8; /* Tailwind sky-400 */
        }
        .auth-btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }
        .auth-btn:hover {
            transform: translateY(-1px);
        }

        /* --- Estilos para la Animación de Scroll (Scroll Reveal) --- */
        .scroll-reveal {
            opacity: 0;
            transform: translateX(-100px); /* Oculto a la izquierda por defecto */
            transition: opacity 1s ease-out, transform 1s ease-out;
            will-change: opacity, transform;
        }
        .scroll-reveal.visible {
            opacity: 1;
            transform: translateX(0);
        }
        /* Para que el segundo elemento entre desde la derecha (opcional pero elegante) */
        .scroll-reveal:nth-child(even) {
            transform: translateX(100px); /* Oculto a la derecha */
        }
        .scroll-reveal:nth-child(even).visible {
            transform: translateX(0);
        }

        /* Responsividad */
        @media (max-width: 768px) {
            #chartContainer { height: 45vh; }
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center">

    <!-- SECCIÓN 1: ENCABEZADO Y TCKER -->
    <header class="w-full max-w-7xl text-center py-4 mb-4">
        <h1 class="text-4xl font-extrabold text-teal-400">Herramientas fundamentales de arbitraje</h1>
    </header>

    <!-- CONTENEDOR PRINCIPAL: PANEL DE PRECIOS Y AUTENTICACIÓN -->
    <div class="w-full max-w-7xl flex flex-col md:flex-row justify-between gap-4 mb-6">
        
        <!-- Panel de Precios (Izquierda/Arriba) -->
        <div id="price-panel" class="w-full md:w-2/3 bg-[#161b22] p-4 rounded-lg shadow-xl border border-teal-500/50">
            <!-- Ticker Principal -->
            <div class="p-2">
                <span class="text-xl md:text-2xl font-bold text-gray-300">Token Digital (TKN/USD)</span>
                <div class="flex items-end mt-1">
                    <span id="current-price" class="text-4xl md:text-5xl font-extrabold text-green-400 mr-4">$0.00</span>
                    <span id="price-change" class="text-lg md:text-xl font-semibold text-green-500">
                        <span id="change-icon">▲</span> <span id="change-value">0.00%</span>
                    </span>
                </div>
            </div>
        </div>

        <!-- Panel de Autenticación (Derecha/Abajo) -->
        <div id="auth-panel" class="w-full md:w-1/3 bg-[#161b22] p-4 rounded-lg shadow-xl border border-purple-500/50 flex flex-col justify-center">
            <!-- Contenido de Autenticación se renderizará aquí -->
        </div>

    </div>

    <!-- SECCIÓN 2: GRÁFICA INTERACTIVA -->
    <div id="chartContainer" class="p-2 mb-10 w-full max-w-7xl">
        <canvas id="cryptoChart"></canvas>
    </div>

    <!-- SECCIÓN 3: HERRAMIENTAS DE ANÁLISIS TÉCNICO (Acordeón y Scroll Reveal) -->
    <main class="w-full max-w-7xl px-4 md:px-0">
        <h2 class="text-3xl font-bold text-purple-400 mb-6 border-b border-gray-700 pb-2">Herramientas Clave de Análisis Gráfico</h2>
        
        <div class="grid md:grid-cols-2 gap-6 mb-12">
            
            <!-- Herramienta 1: Medias Móviles (MA) -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>
                        Medias Móviles (MA)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0" data-arrow-icon="ma" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="accordion-content" data-content="ma">
                    <p class="text-gray-400 text-sm mt-2">Las Medias Móviles son indicadores de tendencia que suavizan la acción del precio en un periodo de tiempo específico. Ayudan a identificar la dirección de la tendencia, los niveles de soporte y resistencia dinámicos, y a generar señales de cruce.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li>**Uso Común:** Determinar la tendencia general y la velocidad del movimiento.</li>
                        <li>**Tipos:** Simple (SMA), Exponencial (EMA). La EMA reacciona más rápido a los cambios recientes.</li>
                        <li>**Señales:** Un cruce de precio por encima de la MA sugiere un impulso alcista; por debajo, bajista.</li>
                    </ul>
                </div>
            </div>
            
            <!-- Herramienta 2: Índice de Fuerza Relativa (RSI) -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0h2m4 0V5a2 2 0 00-2-2h-2a2 2 0 00-2 2v14m0 0h2m2-14h2m-2 2h2m-2 4h2m-2 4h2"></path></svg>
                        Índice de Fuerza Relativa (RSI)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0" data-arrow-icon="rsi" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="accordion-content" data-content="rsi">
                    <p class="text-gray-400 text-sm mt-2">El RSI es un oscilador de momentum que mide la velocidad y el cambio de los movimientos de precios. Oscila entre 0 y 100, siendo esencial para determinar si un activo está sobrecomprado o sobrevendido, lo que podría indicar una inminente corrección o reversión.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li>**Sobrecompra:** Valores superiores a 70 (señal bajista potencial).</li>
                        <li>**Sobreventa:** Valores inferiores a 30 (señal alcista potencial).</li>
                        <li>**Divergencia:** Diferencia entre el RSI y el precio, a menudo el mejor predictor de reversiones.</li>
                    </ul>
                </div>
            </div>
            
            <!-- Herramienta 3: Bandas de Bollinger (BB) -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l2 2 4-4m5 4h.01M9 16h.01M19 16h.01M9 20h.01"></path></svg>
                        Bandas de Bollinger (BB)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0" data-arrow-icon="bb" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="accordion-content" data-content="bb">
                    <p class="text-gray-400 text-sm mt-2">Las Bandas de Bollinger consisten en una Media Móvil central y dos bandas de desviación estándar (superior e inferior). Miden la volatilidad del mercado: cuando las bandas se estrechan (apretón), sugiere baja volatilidad antes de un movimiento brusco; cuando se expanden, indica alta volatilidad.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li>**Banda Superior:** Actúa como resistencia; el precio rara vez la supera.</li>
                        <li>**Banda Inferior:** Actúa como soporte; el precio rara vez la perfora.</li>
                        <li>**Squeeze:** El estrechamiento de las bandas predice una explosión de volatilidad inminente.</li>
                    </ul>
                </div>
            </div>

            <!-- Herramienta 4: MACD (Convergencia/Divergencia) -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l2 2 4-4 2 2 4-4m-12 3v3m0 3h.01M16 8h.01M9 8h.01M7 16h.01M16 16h.01"></path></svg>
                        MACD (Convergencia/Divergencia)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0" data-arrow-icon="macd" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="accordion-content" data-content="macd">
                    <p class="text-gray-400 text-sm mt-2">El MACD es un indicador de seguimiento de tendencia que muestra la relación entre dos Medias Móviles Exponenciales (EMA). Consiste en la línea MACD (diferencia entre dos EMA), la línea de Señal (EMA del MACD) y un Histograma que representa la diferencia entre ambas, indicando el momentum.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li>**Señal de Compra:** Cuando la línea MACD cruza por encima de la línea de Señal.</li>
                        <li>**Señal de Venta:** Cuando la línea MACD cruza por debajo de la línea de Señal.</li>
                        <li>**Cruce de Cero:** Un cruce del MACD por encima de la línea cero confirma un cambio de tendencia.</li>
                    </ul>
                </div>
            </div>

        </div>
    </main>
    
    <!-- SECCIÓN 4: CÓDIGO JAVASCRIPT -->
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONSTANTES DEL DOM Y CONFIGURACIÓN ---
            const chartCanvas = document.getElementById('cryptoChart');
            const chartCtx = chartCanvas.getContext('2d');
            const chartContainerElement = document.getElementById('chartContainer');
            const currentPriceElement = document.getElementById('current-price');
            const priceChangeElement = document.getElementById('change-value');
            const changeIconElement = document.getElementById('change-icon');
            const authPanel = document.getElementById('auth-panel'); 
            
            // --- CONFIGURACIÓN DE LA SIMULACIÓN DE TRADING ---
            const CANDLE_COUNT = 60; 
            const PRICE_BASE = 85.00; 
            const PRICE_VOLATILITY = 5.00; 
            const PRICE_DECAY = 0.9995; 
            let lastClosePrice = PRICE_BASE;
            let candles = []; 

            // --- LÓGICA DE AUTENTICACIÓN ---

            const STORAGE_KEY = 'tkn_current_user';
            let currentUser = null; 

            /**
             * Intenta cargar el usuario de localStorage al inicio.
             */
            function loadUserFromStorage() {
                const userData = localStorage.getItem(STORAGE_KEY);
                if (userData) {
                    try {
                        currentUser = JSON.parse(userData);
                    } catch (e) {
                        console.error("Error al parsear datos de usuario de localStorage", e);
                        currentUser = null;
                        localStorage.removeItem(STORAGE_KEY);
                    }
                }
            }

            /**
             * Guarda la información del usuario en localStorage.
             * Ahora guarda email, teléfono y CONTRASEÑA.
             * @param {Object} user - Objeto con los datos del usuario (email, phone, password, etc.)
             */
            function saveUserToStorage(user) {
                // !!! ADVERTENCIA DE SEGURIDAD CRÍTICA !!!
                // En una aplicación real, NUNCA se debe guardar la contraseña (user.password) 
                // en texto plano en localStorage, ni siquiera para "comunicación". 
                currentUser = { 
                    email: user.email, 
                    phone: user.phone || null, 
                    password: user.password || null // Guardando la contraseña según solicitud.
                }; 
                localStorage.setItem(STORAGE_KEY, JSON.stringify(currentUser));
                renderAuthPanel();
            }

            /**
             * Cierra la sesión y elimina el usuario de localStorage.
             */
            function logout() {
                currentUser = null;
                localStorage.removeItem(STORAGE_KEY);
                renderAuthPanel();
            }

            /**
             * Simula el registro de un nuevo usuario.
             */
            function handleRegister(email, phone, password) {
                // Validación: email y contraseña (mínimo 6) obligatorios. Teléfono es opcional.
                if (!email || password.length < 6) {
                    displayMessage('El email y la contraseña (mínimo 6 caracteres) son obligatorios.', 'red');
                    return;
                }
                if (phone && isNaN(phone.replace(/\s/g, ''))) {
                    displayMessage('El campo de teléfono debe ser un número válido.', 'red');
                    return;
                }
                
                // Simulación de que el registro es exitoso
                displayMessage(`¡Registro exitoso para ${email}! Iniciando sesión...`, 'green');
                // Se guardan email, phone Y password.
                saveUserToStorage({ email, phone, password });
            }

            /**
             * Simula el inicio de sesión.
             */
            function handleLogin(email, password) {
                // Validación simple
                if (!email || !password) {
                    displayMessage('Introduce tu email y contraseña.', 'red');
                    return;
                }

                // Simulación: cualquier email con una contraseña de 6+ caracteres es válido
                if (password.length >= 6) {
                    displayMessage(`¡Bienvenido de nuevo, ${email}!`, 'green');
                    // Al iniciar sesión, solo necesitamos el email, ya que el resto de datos 
                    // (teléfono/contraseña) ya están en localStorage si se registraron previamente.
                    saveUserToStorage({ email }); 
                } else {
                    displayMessage('Credenciales incorrectas (Simulación).', 'red');
                }
            }

            /**
             * Muestra un mensaje temporal en el panel de autenticación.
             */
            function displayMessage(message, color) {
                const messageBox = authPanel.querySelector('#auth-message');
                if (messageBox) {
                    // Clases hardcodeadas para Tailwind dinámico
                    const bgColor = color === 'red' ? 'bg-red-600/80' : 'bg-green-600/80';
                    messageBox.className = `p-2 mb-3 text-sm rounded-lg text-white ${bgColor}`;
                    messageBox.textContent = message;
                    setTimeout(() => {
                        messageBox.textContent = '';
                        messageBox.className = 'mb-3';
                    }, 4000);
                }
            }

            /**
             * Renderiza el formulario de Login/Register o la info del usuario.
             */
            function renderAuthPanel(mode = 'login') {
                authPanel.innerHTML = `<div id="auth-message" class="mb-3"></div>`; 
                
                if (currentUser) {
                    // Estado Logueado
                    // Muestra el email, teléfono y el recordatorio de la contraseña guardada
                    const phoneDisplay = currentUser.phone ? `<p class="text-sm text-gray-400 mb-2">📞 ${currentUser.phone}</p>` : '';
                    const passwordWarning = currentUser.password ? `<p class="text-xs text-red-400 italic">⚠️ Contraseña guardada: ${currentUser.password}</p>` : '';
                    
                    authPanel.innerHTML += `
                        <div class="text-center">
                            <h3 class="text-xl font-bold text-teal-400">Bienvenido</h3>
                            <p class="text-sm text-gray-300 truncate mb-1">📧 ${currentUser.email}</p>
                            ${phoneDisplay}
                            ${passwordWarning}
                            <button id="logout-btn" class="auth-btn bg-red-600 hover:bg-red-700 text-white w-full mt-4">Cerrar Sesión</button>
                        </div>
                    `;
                    document.getElementById('logout-btn').addEventListener('click', logout);
                } else {
                    // Estado Deslogueado (Login/Register)
                    let phoneInputHTML = '';
                    if (mode === 'register') {
                        phoneInputHTML = `<input type="tel" id="auth-phone" class="auth-input" placeholder="Teléfono (Opcional)">`;
                    }

                    const formHTML = `
                        <h3 class="text-xl font-bold text-purple-400 mb-4">${mode === 'login' ? 'Iniciar Sesión' : 'Registro'}</h3>
                        <form id="auth-form" class="flex flex-col space-y-3">
                            <input type="email" id="auth-email" class="auth-input" placeholder="Email" required>
                            ${phoneInputHTML} <!-- Campo de teléfono -->
                            <input type="password" id="auth-password" class="auth-input" placeholder="Contraseña (mín. 6)" required>
                            
                            <button type="submit" class="auth-btn bg-indigo-600 hover:bg-indigo-700 text-white">
                                ${mode === 'login' ? 'Acceder' : 'Registrarse'}
                            </button>
                        </form>
                        <p class="text-center text-xs mt-3 text-gray-400">
                            ${mode === 'login' 
                                ? '¿No tienes cuenta? <a href="#" id="toggle-register" class="text-purple-400 hover:text-purple-300">Regístrate</a>'
                                : '¿Ya tienes cuenta? <a href="#" id="toggle-login" class="text-purple-400 hover:text-purple-300">Inicia Sesión</a>'
                            }
                        </p>
                    `;
                    authPanel.innerHTML += formHTML;

                    // Manejo del envío del formulario
                    document.getElementById('auth-form').addEventListener('submit', (e) => {
                        e.preventDefault();
                        const email = document.getElementById('auth-email').value;
                        const password = document.getElementById('auth-password').value;
                        
                        if (mode === 'register') {
                            const phone = document.getElementById('auth-phone').value;
                            handleRegister(email, phone, password);
                        } else {
                            handleLogin(email, password);
                        }
                    });

                    // Manejo del cambio de modo
                    if (document.getElementById('toggle-register')) {
                        document.getElementById('toggle-register').addEventListener('click', (e) => {
                            e.preventDefault();
                            renderAuthPanel('register');
                        });
                    }
                    if (document.getElementById('toggle-login')) {
                        document.getElementById('toggle-login').addEventListener('click', (e) => {
                            e.preventDefault();
                            renderAuthPanel('login');
                        });
                    }
                }
            }

            // Inicializar la autenticación
            loadUserFromStorage();
            renderAuthPanel(currentUser ? 'logged' : 'login');


            // --- FIN DE LÓGICA DE AUTENTICACIÓN ---


            // --- LÓGICA DE LA GRÁFICA ---

            /**
             * Genera una nueva vela (OHLC) basándose en el precio de cierre anterior.
             */
            function generateNewCandle() {
                const open = lastClosePrice;
                let close = open + (Math.random() * PRICE_VOLATILITY * 2 - PRICE_VOLATILITY) * (1 + (Math.random() - 0.5) * 0.1);
                
                const driftFactor = 1 - (close - PRICE_BASE) / (PRICE_BASE * 10) * (1 - PRICE_DECAY);
                close *= driftFactor;

                const bodyMin = Math.min(open, close);
                const bodyMax = Math.max(open, close);

                const high = bodyMax + Math.random() * PRICE_VOLATILITY * 0.2;
                const low = bodyMin - Math.random() * PRICE_VOLATILITY * 0.2;

                const finalLow = Math.min(low, bodyMin);
                const finalHigh = Math.max(high, bodyMax);

                lastClosePrice = close;

                return { open, high: finalHigh, low: finalLow, close, timestamp: Date.now() };
            }

            /**
             * Genera los datos iniciales de las velas.
             */
            function initializeCandles() {
                for (let i = 0; i < CANDLE_COUNT; i++) {
                    const newCandle = generateNewCandle();
                    candles.push(newCandle);
                    lastClosePrice = newCandle.close;
                }
                lastClosePrice = candles[candles.length - 1].close;
            }
            
            initializeCandles();


            /**
             * Normaliza las coordenadas del precio a la posición Y del canvas.
             */
            function getY(price, minPrice, maxPrice, height) {
                const priceRange = maxPrice - minPrice;
                const normalizedY = 1 - ((price - minPrice) / priceRange);
                return normalizedY * height;
            }

            /**
             * Dibuja la gráfica de velas en el canvas.
             */
            function drawChart() {
                const width = chartCanvas.width;
                const height = chartCanvas.height;

                chartCtx.clearRect(0, 0, width, height);
                
                // Rango de precios y buffer
                const prices = candles.flatMap(c => [c.high, c.low]);
                if (prices.length === 0) return;
                
                const minPrice = Math.min(...prices) * 0.9999; 
                const maxPrice = Math.max(...prices) * 1.0001; 
                const priceRange = maxPrice - minPrice;
                
                const candleSpacing = width / CANDLE_COUNT;
                const currentCandleWidth = candleSpacing * 0.7; 

                // 1. Dibujar Cuadrícula
                chartCtx.strokeStyle = '#2d333b'; 
                chartCtx.lineWidth = 1;
                const gridLines = 5;
                for (let i = 0; i < gridLines; i++) {
                    const y = (height / (gridLines - 1)) * i;
                    chartCtx.beginPath();
                    chartCtx.moveTo(0, y);
                    chartCtx.lineTo(width, y);
                    chartCtx.stroke();
                }

                // 2. Dibujar Velas (Candlesticks)
                candles.forEach((candle, index) => {
                    const x = index * candleSpacing + (candleSpacing - currentCandleWidth) / 2;

                    const yOpen = getY(candle.open, minPrice, maxPrice, height);
                    const yClose = getY(candle.close, minPrice, maxPrice, height);
                    const yHigh = getY(candle.high, minPrice, maxPrice, height);
                    const yLow = getY(candle.low, minPrice, maxPrice, height);

                    const isBullish = candle.close > candle.open;
                    const color = isBullish ? '#10b981' : '#ef4444'; 
                    
                    chartCtx.fillStyle = color;
                    chartCtx.strokeStyle = color;
                    chartCtx.lineWidth = 1;

                    // Dibujar la Mecha
                    chartCtx.beginPath();
                    chartCtx.moveTo(x + currentCandleWidth / 2, yHigh);
                    chartCtx.lineTo(x + currentCandleWidth / 2, yLow);
                    chartCtx.stroke();

                    // Dibujar el Cuerpo
                    const bodyTop = Math.min(yOpen, yClose);
                    const bodyHeight = Math.abs(yOpen - yClose);
                    const actualBodyHeight = Math.max(1, bodyHeight);
                    const actualBodyTop = bodyHeight < 1 ? (isBullish ? yClose - 0.5 : yOpen - 0.5) : bodyTop;

                    chartCtx.fillRect(x, actualBodyTop, currentCandleWidth, actualBodyHeight);
                });

                // 3. Dibujar Eje de Precios (Derecha)
                chartCtx.font = '10px Inter';
                chartCtx.fillStyle = '#e6e6e6'; 
                
                for (let i = 0; i < gridLines; i++) {
                    const y = (height / (gridLines - 1)) * i;
                    const price = maxPrice - (priceRange / (gridLines - 1)) * i;
                    const formattedPrice = '$' + price.toFixed(2);
                    
                    chartCtx.textAlign = 'left';
                    chartCtx.fillText(formattedPrice, width + 5, y + 3);
                    
                    chartCtx.beginPath();
                    chartCtx.moveTo(width, y);
                    chartCtx.lineTo(width - 5, y);
                    chartCtx.stroke();
                }

                // 4. Dibujar Precio Actual (Línea de Close)
                const lastY = getY(lastClosePrice, minPrice, maxPrice, height);
                const lastClosePriceFormatted = lastClosePrice.toFixed(2);

                chartCtx.strokeStyle = '#e6e6e6';
                chartCtx.lineWidth = 2;
                chartCtx.setLineDash([5, 5]);
                chartCtx.beginPath();
                chartCtx.moveTo(0, lastY);
                chartCtx.lineTo(width, lastY);
                chartCtx.stroke();
                chartCtx.setLineDash([]); 

                chartCtx.fillStyle = '#e6e6e6';
                chartCtx.textAlign = 'right';
                chartCtx.fillRect(width, lastY - 8, 70, 16);
                chartCtx.fillStyle = '#161b22'; 
                chartCtx.fillText('$' + lastClosePriceFormatted, width + 65, lastY + 4);

                updatePricePanel(candles);
            }

            /**
             * Actualiza el panel de precios principal con la última vela.
             */
            function updatePricePanel(currentCandles) {
                if (currentCandles.length < 2) return;

                const lastCandle = currentCandles[currentCandles.length - 1];
                const prevCandle = currentCandles[currentCandles.length - 2]; 

                const currentPrice = lastCandle.close;
                const change = currentPrice - prevCandle.close;
                const percentageChange = (change / prevCandle.close) * 100;
                
                const isPositive = change >= 0;
                const priceClass = isPositive ? 'text-green-400' : 'text-red-400';
                const changeClass = isPositive ? 'text-green-500' : 'text-red-500';
                const changeIcon = isPositive ? '▲' : '▼';

                currentPriceElement.textContent = '$' + currentPrice.toFixed(2);
                currentPriceElement.className = `text-4xl md:text-5xl font-extrabold mr-4 ${priceClass}`;
                
                priceChangeElement.textContent = `${percentageChange.toFixed(2)}%`;
                priceChangeElement.parentElement.className = `text-lg md:text-xl font-semibold ${changeClass}`;
                
                changeIconElement.textContent = changeIcon;
            }


            /**
             * Función para actualizar la gráfica con nuevos datos (cada segundo).
             */
            function updateChartData() {
                candles.shift();
                candles.push(generateNewCandle());
                drawChart();
            }

            // --- LÓGICA DE REDIMENSIONAMIENTO RESPONSIVO ---
            const chartResizeObserver = new ResizeObserver(entries => {
                const containerEntry = entries.find(entry => entry.target === chartContainerElement);
                if (!containerEntry) return;
                
                const newRect = containerEntry.contentRect;
                // El ancho debe ser todo el contenedor menos el espacio para las etiquetas de precio
                chartCanvas.width = newRect.width - 75; 
                chartCanvas.height = newRect.height;
                
                drawChart();
            });
            
            chartResizeObserver.observe(chartContainerElement); 

            // Inicio del loop de simulación
            drawChart();
            setInterval(updateChartData, 1000);
            
            
            // --- LÓGICA DE ACORDEÓN (Botón Desplegable) ---

            /**
             * Alterna la visibilidad y aplica la transición del contenido del acordeón.
             * @param {HTMLElement} headerElement - El elemento que contiene el título (donde se hizo click).
             */
            window.toggleAccordion = function(headerElement) {
                const parentCard = headerElement.closest('.content-card');
                const content = parentCard.querySelector('.accordion-content');
                const arrowIcon = headerElement.querySelector('[data-arrow-icon]');

                // Alternar la clase 'open' para activar las transiciones CSS
                content.classList.toggle('open');

                // Rotar el icono de flecha
                if (content.classList.contains('open')) {
                    arrowIcon.classList.remove('rotate-0');
                    arrowIcon.classList.add('rotate-180');
                } else {
                    arrowIcon.classList.remove('rotate-180');
                    arrowIcon.classList.add('rotate-0');
                }
            };

            
            // --- LÓGICA DE ANIMACIÓN AL HACER SCROLL (Intersection Observer) ---
            
            const scrollRevealElements = document.querySelectorAll('.scroll-reveal');

            const observerOptions = {
                root: null, // El viewport es el elemento raíz
                rootMargin: '0px',
                threshold: 0.2 // Se activa cuando el 20% del elemento es visible
            };

            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Si el elemento es visible, añade la clase 'visible'
                        entry.target.classList.add('visible');
                        // Deja de observar el elemento una vez que se ha animado
                        observer.unobserve(entry.target);
                    }
                });
            }, observerOptions);

            // Empezar a observar todos los elementos
            scrollRevealElements.forEach(el => {
                observer.observe(el);
            });


        });
    </script>
</body>
</html>
