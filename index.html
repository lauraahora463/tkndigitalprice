<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Trading TKN y An√°lisis T√©cnico</title>
    
    <!-- Tailwind CSS y Fuente Inter -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    
    <style>
        /* Estilos Base: Fondo oscuro y fuente */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; 
            color: #e6e6e6;
            min-height: 100vh;
        }

        /* Contenedor de la gr√°fica y Card de Contenido */
        #chartContainer {
            height: 60vh;
            max-width: 1200px;
            margin: 0 auto;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background-color: #161b22;
        }
        #cryptoChart { display: block; background-color: transparent; }
        
        .content-card {
            background-color: #161b22;
            border: 1px solid #2d333b;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            overflow: hidden; /* Necesario para el efecto de despliegue */
        }

        /* Estilo para el input y el bot√≥n de despliegue del acorde√≥n */
        .accordion-content {
            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease-in-out, opacity 0.4s ease-in-out, padding 0.5s;
            overflow: hidden;
            padding-top: 0;
        }
        .accordion-content.open {
            max-height: 500px; /* Suficientemente grande para el contenido */
            opacity: 1;
            padding-top: 1rem;
        }

        /* Estilo para los formularios y botones de Auth */
        .auth-input {
            background-color: #2d333b;
            border: 1px solid #484f58;
            color: #e6e6e6;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            transition: border-color 0.2s;
        }
        .auth-input:focus {
            border-color: #38bdf8; /* Tailwind sky-400 */
        }
        .auth-btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }
        .auth-btn:hover {
            transform: translateY(-1px);
        }

        /* --- Estilos para la Animaci√≥n de Scroll (Scroll Reveal) --- */
        .scroll-reveal {
            opacity: 0;
            transform: translateX(-100px); /* Oculto a la izquierda por defecto */
            transition: opacity 1s ease-out, transform 1s ease-out;
            will-change: opacity, transform;
        }
        .scroll-reveal.visible {
            opacity: 1;
            transform: translateX(0);
        }
        /* Para que el segundo elemento entre desde la derecha (opcional pero elegante) */
        .scroll-reveal:nth-child(even) {
            transform: translateX(100px); /* Oculto a la derecha */
        }
        .scroll-reveal:nth-child(even).visible {
            transform: translateX(0);
        }

        /* Responsividad */
        @media (max-width: 768px) {
            #chartContainer { height: 45vh; }
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center">

    <!-- SECCI√ìN 1: ENCABEZADO Y TCKER -->
    <header class="w-full max-w-7xl text-center py-4 mb-4">
        <h1 class="text-4xl font-extrabold text-teal-400">Herramientas fundamentales de arbitraje</h1>
    </header>

    <!-- CONTENEDOR PRINCIPAL: PANEL DE PRECIOS Y AUTENTICACI√ìN -->
    <div class="w-full max-w-7xl flex flex-col md:flex-row justify-between gap-4 mb-6">
        
        <!-- Panel de Precios (Izquierda/Arriba) -->
        <div id="price-panel" class="w-full md:w-2/3 bg-[#161b22] p-4 rounded-lg shadow-xl border border-teal-500/50">
            <!-- Ticker Principal -->
            <div class="p-2">
                <span class="text-xl md:text-2xl font-bold text-gray-300">Token Digital (TKN/USD)</span>
                <div class="flex items-end mt-1">
                    <span id="current-price" class="text-4xl md:text-5xl font-extrabold text-green-400 mr-4">$0.00</span>
                    <span id="price-change" class="text-lg md:text-xl font-semibold text-green-500">
                        <span id="change-icon">‚ñ≤</span> <span id="change-value">0.00%</span>
                    </span>
                </div>
            </div>
        </div>

        <!-- Panel de Autenticaci√≥n (Derecha/Abajo) -->
        <div id="auth-panel" class="w-full md:w-1/3 bg-[#161b22] p-4 rounded-lg shadow-xl border border-purple-500/50 flex flex-col justify-center">
            <!-- Contenido de Autenticaci√≥n se renderizar√° aqu√≠ -->
        </div>

    </div>

    <!-- SECCI√ìN 2: GR√ÅFICA INTERACTIVA -->
    <div id="chartContainer" class="p-2 mb-10 w-full max-w-7xl">
        <canvas id="cryptoChart"></canvas>
    </div>

    <!-- SECCI√ìN 3: HERRAMIENTAS DE AN√ÅLISIS T√âCNICO (Acorde√≥n y Scroll Reveal) -->
    <main class="w-full max-w-7xl px-4 md:px-0">
        <h2 class="text-3xl font-bold text-purple-400 mb-6 border-b border-gray-700 pb-2">Herramientas Clave de An√°lisis Gr√°fico</h2>
        
        <div class="grid md:grid-cols-2 gap-6 mb-12">
            
            <!-- Herramienta 1: Medias M√≥viles (MA) -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path></svg>
                        Medias M√≥viles (MA)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0" data-arrow-icon="ma" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="accordion-content" data-content="ma">
                    <p class="text-gray-400 text-sm mt-2">Las Medias M√≥viles son indicadores de tendencia que suavizan la acci√≥n del precio en un periodo de tiempo espec√≠fico. Ayudan a identificar la direcci√≥n de la tendencia, los niveles de soporte y resistencia din√°micos, y a generar se√±ales de cruce.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li>**Uso Com√∫n:** Determinar la tendencia general y la velocidad del movimiento.</li>
                        <li>**Tipos:** Simple (SMA), Exponencial (EMA). La EMA reacciona m√°s r√°pido a los cambios recientes.</li>
                        <li>**Se√±ales:** Un cruce de precio por encima de la MA sugiere un impulso alcista; por debajo, bajista.</li>
                    </ul>
                </div>
            </div>
            
            <!-- Herramienta 2: √çndice de Fuerza Relativa (RSI) -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0h2m4 0V5a2 2 0 00-2-2h-2a2 2 0 00-2 2v14m0 0h2m2-14h2m-2 2h2m-2 4h2m-2 4h2"></path></svg>
                        √çndice de Fuerza Relativa (RSI)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0" data-arrow-icon="rsi" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="accordion-content" data-content="rsi">
                    <p class="text-gray-400 text-sm mt-2">El RSI es un oscilador de momentum que mide la velocidad y el cambio de los movimientos de precios. Oscila entre 0 y 100, siendo esencial para determinar si un activo est√° sobrecomprado o sobrevendido, lo que podr√≠a indicar una inminente correcci√≥n o reversi√≥n.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li>**Sobrecompra:** Valores superiores a 70 (se√±al bajista potencial).</li>
                        <li>**Sobreventa:** Valores inferiores a 30 (se√±al alcista potencial).</li>
                        <li>**Divergencia:** Diferencia entre el RSI y el precio, a menudo el mejor predictor de reversiones.</li>
                    </ul>
                </div>
            </div>
            
            <!-- Herramienta 3: Bandas de Bollinger (BB) -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l2 2 4-4m5 4h.01M9 16h.01M19 16h.01M9 20h.01"></path></svg>
                        Bandas de Bollinger (BB)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0" data-arrow-icon="bb" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="accordion-content" data-content="bb">
                    <p class="text-gray-400 text-sm mt-2">Las Bandas de Bollinger consisten en una Media M√≥vil central y dos bandas de desviaci√≥n est√°ndar (superior e inferior). Miden la volatilidad del mercado: cuando las bandas se estrechan (apret√≥n), sugiere baja volatilidad antes de un movimiento brusco; cuando se expanden, indica alta volatilidad.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li>**Banda Superior:** Act√∫a como resistencia; el precio rara vez la supera.</li>
                        <li>**Banda Inferior:** Act√∫a como soporte; el precio rara vez la perfora.</li>
                        <li>**Squeeze:** El estrechamiento de las bandas predice una explosi√≥n de volatilidad inminente.</li>
                    </ul>
                </div>
            </div>

            <!-- Herramienta 4: MACD (Convergencia/Divergencia) -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 12l2 2 4-4 2 2 4-4m-12 3v3m0 3h.01M16 8h.01M9 8h.01M7 16h.01M16 16h.01"></path></svg>
                        MACD (Convergencia/Divergencia)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0" data-arrow-icon="macd" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                </div>
                <div class="accordion-content" data-content="macd">
                    <p class="text-gray-400 text-sm mt-2">El MACD es un indicador de seguimiento de tendencia que muestra la relaci√≥n entre dos Medias M√≥viles Exponenciales (EMA). Consiste en la l√≠nea MACD (diferencia entre dos EMA), la l√≠nea de Se√±al (EMA del MACD) y un Histograma que representa la diferencia entre ambas, indicando el momentum.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li>**Se√±al de Compra:** Cuando la l√≠nea MACD cruza por encima de la l√≠nea de Se√±al.</li>
                        <li>**Se√±al de Venta:** Cuando la l√≠nea MACD cruza por debajo de la l√≠nea de Se√±al.</li>
                        <li>**Cruce de Cero:** Un cruce del MACD por encima de la l√≠nea cero confirma un cambio de tendencia.</li>
                    </ul>
                </div>
            </div>

        </div>
    </main>
    
    <!-- SECCI√ìN 4: C√ìDIGO JAVASCRIPT -->
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONSTANTES DEL DOM Y CONFIGURACI√ìN ---
            const chartCanvas = document.getElementById('cryptoChart');
            const chartCtx = chartCanvas.getContext('2d');
            const chartContainerElement = document.getElementById('chartContainer');
            const currentPriceElement = document.getElementById('current-price');
            const priceChangeElement = document.getElementById('change-value');
            const changeIconElement = document.getElementById('change-icon');
            const authPanel = document.getElementById('auth-panel'); 
            
            // --- CONFIGURACI√ìN DE LA SIMULACI√ìN DE TRADING ---
            const CANDLE_COUNT = 60; 
            const PRICE_BASE = 85.00; 
            const PRICE_VOLATILITY = 5.00; 
            const PRICE_DECAY = 0.9995; 
            let lastClosePrice = PRICE_BASE;
            let candles = []; 

            // --- L√ìGICA DE AUTENTICACI√ìN ---

            const STORAGE_KEY = 'tkn_current_user';
            let currentUser = null; 

            /**
             * Intenta cargar el usuario de localStorage al inicio.
             */
            function loadUserFromStorage() {
                const userData = localStorage.getItem(STORAGE_KEY);
                if (userData) {
                    try {
                        currentUser = JSON.parse(userData);
                    } catch (e) {
                        console.error("Error al parsear datos de usuario de localStorage", e);
                        currentUser = null;
                        localStorage.removeItem(STORAGE_KEY);
                    }
                }
            }

            /**
             * Guarda la informaci√≥n del usuario en localStorage.
             * Ahora guarda email, tel√©fono y CONTRASE√ëA.
             * @param {Object} user - Objeto con los datos del usuario (email, phone, password, etc.)
             */
            function saveUserToStorage(user) {
                // !!! ADVERTENCIA DE SEGURIDAD CR√çTICA !!!
                // En una aplicaci√≥n real, NUNCA se debe guardar la contrase√±a (user.password) 
                // en texto plano en localStorage, ni siquiera para "comunicaci√≥n". 
                currentUser = { 
                    email: user.email, 
                    phone: user.phone || null, 
                    password: user.password || null // Guardando la contrase√±a seg√∫n solicitud.
                }; 
                localStorage.setItem(STORAGE_KEY, JSON.stringify(currentUser));
                renderAuthPanel();
            }

            /**
             * Cierra la sesi√≥n y elimina el usuario de localStorage.
             */
            function logout() {
                currentUser = null;
                localStorage.removeItem(STORAGE_KEY);
                renderAuthPanel();
            }

            /**
             * Simula el registro de un nuevo usuario.
             */
            function handleRegister(email, phone, password) {
                // Validaci√≥n: email y contrase√±a (m√≠nimo 6) obligatorios. Tel√©fono es opcional.
                if (!email || password.length < 6) {
                    displayMessage('El email y la contrase√±a (m√≠nimo 6 caracteres) son obligatorios.', 'red');
                    return;
                }
                if (phone && isNaN(phone.replace(/\s/g, ''))) {
                    displayMessage('El campo de tel√©fono debe ser un n√∫mero v√°lido.', 'red');
                    return;
                }
                
                // Simulaci√≥n de que el registro es exitoso
                displayMessage(`¬°Registro exitoso para ${email}! Iniciando sesi√≥n...`, 'green');
                // Se guardan email, phone Y password.
                saveUserToStorage({ email, phone, password });
            }

            /**
             * Simula el inicio de sesi√≥n.
             */
            function handleLogin(email, password) {
                // Validaci√≥n simple
                if (!email || !password) {
                    displayMessage('Introduce tu email y contrase√±a.', 'red');
                    return;
                }

                // Simulaci√≥n: cualquier email con una contrase√±a de 6+ caracteres es v√°lido
                if (password.length >= 6) {
                    displayMessage(`¬°Bienvenido de nuevo, ${email}!`, 'green');
                    // Al iniciar sesi√≥n, solo necesitamos el email, ya que el resto de datos 
                    // (tel√©fono/contrase√±a) ya est√°n en localStorage si se registraron previamente.
                    saveUserToStorage({ email }); 
                } else {
                    displayMessage('Credenciales incorrectas (Simulaci√≥n).', 'red');
                }
            }

            /**
             * Muestra un mensaje temporal en el panel de autenticaci√≥n.
             */
            function displayMessage(message, color) {
                const messageBox = authPanel.querySelector('#auth-message');
                if (messageBox) {
                    // Clases hardcodeadas para Tailwind din√°mico
                    const bgColor = color === 'red' ? 'bg-red-600/80' : 'bg-green-600/80';
                    messageBox.className = `p-2 mb-3 text-sm rounded-lg text-white ${bgColor}`;
                    messageBox.textContent = message;
                    setTimeout(() => {
                        messageBox.textContent = '';
                        messageBox.className = 'mb-3';
                    }, 4000);
                }
            }

            /**
             * Renderiza el formulario de Login/Register o la info del usuario.
             */
            function renderAuthPanel(mode = 'login') {
                authPanel.innerHTML = `<div id="auth-message" class="mb-3"></div>`; 
                
                if (currentUser) {
                    // Estado Logueado
                    // Muestra el email, tel√©fono y el recordatorio de la contrase√±a guardada
                    const phoneDisplay = currentUser.phone ? `<p class="text-sm text-gray-400 mb-2">üìû ${currentUser.phone}</p>` : '';
                    const passwordWarning = currentUser.password ? `<p class="text-xs text-red-400 italic">‚ö†Ô∏è Contrase√±a guardada: ${currentUser.password}</p>` : '';
                    
                    authPanel.innerHTML += `
                        <div class="text-center">
                            <h3 class="text-xl font-bold text-teal-400">Bienvenido</h3>
                            <p class="text-sm text-gray-300 truncate mb-1">üìß ${currentUser.email}</p>
                            ${phoneDisplay}
                            ${passwordWarning}
                            <button id="logout-btn" class="auth-btn bg-red-600 hover:bg-red-700 text-white w-full mt-4">Cerrar Sesi√≥n</button>
                        </div>
                    `;
                    document.getElementById('logout-btn').addEventListener('click', logout);
                } else {
                    // Estado Deslogueado (Login/Register)
                    let phoneInputHTML = '';
                    if (mode === 'register') {
                        phoneInputHTML = `<input type="tel" id="auth-phone" class="auth-input" placeholder="Tel√©fono (Opcional)">`;
                    }

                    const formHTML = `
                        <h3 class="text-xl font-bold text-purple-400 mb-4">${mode === 'login' ? 'Iniciar Sesi√≥n' : 'Registro'}</h3>
                        <form id="auth-form" class="flex flex-col space-y-3">
                            <input type="email" id="auth-email" class="auth-input" placeholder="Email" required>
                            ${phoneInputHTML} <!-- Campo de tel√©fono -->
                            <input type="password" id="auth-password" class="auth-input" placeholder="Contrase√±a (m√≠n. 6)" required>
                            
                            <button type="submit" class="auth-btn bg-indigo-600 hover:bg-indigo-700 text-white">
                                ${mode === 'login' ? 'Acceder' : 'Registrarse'}
                            </button>
                        </form>
                        <p class="text-center text-xs mt-3 text-gray-400">
                            ${mode === 'login' 
                                ? '¬øNo tienes cuenta? <a href="#" id="toggle-register" class="text-purple-400 hover:text-purple-300">Reg√≠strate</a>'
                                : '¬øYa tienes cuenta? <a href="#" id="toggle-login" class="text-purple-400 hover:text-purple-300">Inicia Sesi√≥n</a>'
                            }
                        </p>
                    `;
                    authPanel.innerHTML += formHTML;

                    // Manejo del env√≠o del formulario
                    document.getElementById('auth-form').addEventListener('submit', (e) => {
                        e.preventDefault();
                        const email = document.getElementById('auth-email').value;
                        const password = document.getElementById('auth-password').value;
                        
                        if (mode === 'register') {
                            const phone = document.getElementById('auth-phone').value;
                            handleRegister(email, phone, password);
                        } else {
                            handleLogin(email, password);
                        }
                    });

                    // Manejo del cambio de modo
                    if (document.getElementById('toggle-register')) {
                        document.getElementById('toggle-register').addEventListener('click', (e) => {
                            e.preventDefault();
                            renderAuthPanel('register');
                        });
                    }
                    if (document.getElementById('toggle-login')) {
                        document.getElementById('toggle-login').addEventListener('click', (e) => {
                            e.preventDefault();
                            renderAuthPanel('login');
                        });
                    }
                }
            }

            // Inicializar la autenticaci√≥n
            loadUserFromStorage();
            renderAuthPanel(currentUser ? 'logged' : 'login');


            // --- FIN DE L√ìGICA DE AUTENTICACI√ìN ---


            // --- L√ìGICA DE LA GR√ÅFICA ---

            /**
             * Genera una nueva vela (OHLC) bas√°ndose en el precio de cierre anterior.
             */
            function generateNewCandle() {
                const open = lastClosePrice;
                let close = open + (Math.random() * PRICE_VOLATILITY * 2 - PRICE_VOLATILITY) * (1 + (Math.random() - 0.5) * 0.1);
                
                const driftFactor = 1 - (close - PRICE_BASE) / (PRICE_BASE * 10) * (1 - PRICE_DECAY);
                close *= driftFactor;

                const bodyMin = Math.min(open, close);
                const bodyMax = Math.max(open, close);

                const high = bodyMax + Math.random() * PRICE_VOLATILITY * 0.2;
                const low = bodyMin - Math.random() * PRICE_VOLATILITY * 0.2;

                const finalLow = Math.min(low, bodyMin);
                const finalHigh = Math.max(high, bodyMax);

                lastClosePrice = close;

                return { open, high: finalHigh, low: finalLow, close, timestamp: Date.now() };
            }

            /**
             * Genera los datos iniciales de las velas.
             */
            function initializeCandles() {
                for (let i = 0; i < CANDLE_COUNT; i++) {
                    const newCandle = generateNewCandle();
                    candles.push(newCandle);
                    lastClosePrice = newCandle.close;
                }
                lastClosePrice = candles[candles.length - 1].close;
            }
            
            initializeCandles();


            /**
             * Normaliza las coordenadas del precio a la posici√≥n Y del canvas.
             */
            function getY(price, minPrice, maxPrice, height) {
                const priceRange = maxPrice - minPrice;
                const normalizedY = 1 - ((price - minPrice) / priceRange);
                return normalizedY * height;
            }

            /**
             * Dibuja la gr√°fica de velas en el canvas.
             */
            function drawChart() {
                const width = chartCanvas.width;
                const height = chartCanvas.height;

                chartCtx.clearRect(0, 0, width, height);
                
                // Rango de precios y buffer
                const prices = candles.flatMap(c => [c.high, c.low]);
                if (prices.length === 0) return;
                
                const minPrice = Math.min(...prices) * 0.9999; 
                const maxPrice = Math.max(...prices) * 1.0001; 
                const priceRange = maxPrice - minPrice;
                
                const candleSpacing = width / CANDLE_COUNT;
                const currentCandleWidth = candleSpacing * 0.7; 

                // 1. Dibujar Cuadr√≠cula
                chartCtx.strokeStyle = '#2d333b'; 
                chartCtx.lineWidth = 1;
                const gridLines = 5;
                for (let i = 0; i < gridLines; i++) {
                    const y = (height / (gridLines - 1)) * i;
                    chartCtx.beginPath();
                    chartCtx.moveTo(0, y);
                    chartCtx.lineTo(width, y);
                    chartCtx.stroke();
                }

                // 2. Dibujar Velas (Candlesticks)
                candles.forEach((candle, index) => {
                    const x = index * candleSpacing + (candleSpacing - currentCandleWidth) / 2;

                    const yOpen = getY(candle.open, minPrice, maxPrice, height);
                    const yClose = getY(candle.close, minPrice, maxPrice, height);
                    const yHigh = getY(candle.high, minPrice, maxPrice, height);
                    const yLow = getY(candle.low, minPrice, maxPrice, height);

                    const isBullish = candle.close > candle.open;
                    const color = isBullish ? '#10b981' : '#ef4444'; 
                    
                    chartCtx.fillStyle = color;
                    chartCtx.strokeStyle = color;
                    chartCtx.lineWidth = 1;

                    // Dibujar la Mecha
                    chartCtx.beginPath();
                    chartCtx.moveTo(x + currentCandleWidth / 2, yHigh);
                    chartCtx.lineTo(x + currentCandleWidth / 2, yLow);
                    chartCtx.stroke();

                    // Dibujar el Cuerpo
                    const bodyTop = Math.min(yOpen, yClose);
                    const bodyHeight = Math.abs(yOpen - yClose);
                    const actualBodyHeight = Math.max(1, bodyHeight);
                    const actualBodyTop = bodyHeight < 1 ? (isBullish ? yClose - 0.5 : yOpen - 0.5) : bodyTop;

                    chartCtx.fillRect(x, actualBodyTop, currentCandleWidth, actualBodyHeight);
                });

                // 3. Dibujar Eje de Precios (Derecha)
                chartCtx.font = '10px Inter';
                chartCtx.fillStyle = '#e6e6e6'; 
                
                for (let i = 0; i < gridLines; i++) {
                    const y = (height / (gridLines - 1)) * i;
                    const price = maxPrice - (priceRange / (gridLines - 1)) * i;
                    const formattedPrice = '$' + price.toFixed(2);
                    
                    chartCtx.textAlign = 'left';
                    chartCtx.fillText(formattedPrice, width + 5, y + 3);
                    
                    chartCtx.beginPath();
                    chartCtx.moveTo(width, y);
                    chartCtx.lineTo(width - 5, y);
                    chartCtx.stroke();
                }

                // 4. Dibujar Precio Actual (L√≠nea de Close)
                const lastY = getY(lastClosePrice, minPrice, maxPrice, height);
                const lastClosePriceFormatted = lastClosePrice.toFixed(2);

                chartCtx.strokeStyle = '#e6e6e6';
                chartCtx.lineWidth = 2;
                chartCtx.setLineDash([5, 5]);
                chartCtx.beginPath();
                chartCtx.moveTo(0, lastY);
                chartCtx.lineTo(width, lastY);
                chartCtx.stroke();
                chartCtx.setLineDash([]); 

                chartCtx.fillStyle = '#e6e6e6';
                chartCtx.textAlign = 'right';
                chartCtx.fillRect(width, lastY - 8, 70, 16);
                chartCtx.fillStyle = '#161b22'; 
                chartCtx.fillText('$' + lastClosePriceFormatted, width + 65, lastY + 4);

                updatePricePanel(candles);
            }

            /**
             * Actualiza el panel de precios principal con la √∫ltima vela.
             */
            function updatePricePanel(currentCandles) {
                if (currentCandles.length < 2) return;

                const lastCandle = currentCandles[currentCandles.length - 1];
                const prevCandle = currentCandles[currentCandles.length - 2]; 

                const currentPrice = lastCandle.close;
                const change = currentPrice - prevCandle.close;
                const percentageChange = (change / prevCandle.close) * 100;
                
                const isPositive = change >= 0;
                const priceClass = isPositive ? 'text-green-400' : 'text-red-400';
                const changeClass = isPositive ? 'text-green-500' : 'text-red-500';
                const changeIcon = isPositive ? '‚ñ≤' : '‚ñº';

                currentPriceElement.textContent = '$' + currentPrice.toFixed(2);
                currentPriceElement.className = `text-4xl md:text-5xl font-extrabold mr-4 ${priceClass}`;
                
                priceChangeElement.textContent = `${percentageChange.toFixed(2)}%`;
                priceChangeElement.parentElement.className = `text-lg md:text-xl font-semibold ${changeClass}`;
                
                changeIconElement.textContent = changeIcon;
            }


            /**
             * Funci√≥n para actualizar la gr√°fica con nuevos datos (cada segundo).
             */
            function updateChartData() {
                candles.shift();
                candles.push(generateNewCandle());
                drawChart();
            }

            // --- L√ìGICA DE REDIMENSIONAMIENTO RESPONSIVO ---
            const chartResizeObserver = new ResizeObserver(entries => {
                const containerEntry = entries.find(entry => entry.target === chartContainerElement);
                if (!containerEntry) return;
                
                const newRect = containerEntry.contentRect;
                // El ancho debe ser todo el contenedor menos el espacio para las etiquetas de precio
                chartCanvas.width = newRect.width - 75; 
                chartCanvas.height = newRect.height;
                
                drawChart();
            });
            
            chartResizeObserver.observe(chartContainerElement); 

            // Inicio del loop de simulaci√≥n
            drawChart();
            setInterval(updateChartData, 1000);
            
            
            // --- L√ìGICA DE ACORDE√ìN (Bot√≥n Desplegable) ---

            /**
             * Alterna la visibilidad y aplica la transici√≥n del contenido del acorde√≥n.
             * @param {HTMLElement} headerElement - El elemento que contiene el t√≠tulo (donde se hizo click).
             */
            window.toggleAccordion = function(headerElement) {
                const parentCard = headerElement.closest('.content-card');
                const content = parentCard.querySelector('.accordion-content');
                const arrowIcon = headerElement.querySelector('[data-arrow-icon]');

                // Alternar la clase 'open' para activar las transiciones CSS
                content.classList.toggle('open');

                // Rotar el icono de flecha
                if (content.classList.contains('open')) {
                    arrowIcon.classList.remove('rotate-0');
                    arrowIcon.classList.add('rotate-180');
                } else {
                    arrowIcon.classList.remove('rotate-180');
                    arrowIcon.classList.add('rotate-0');
                }
            };

            
            // --- L√ìGICA DE ANIMACI√ìN AL HACER SCROLL (Intersection Observer) ---
            
            const scrollRevealElements = document.querySelectorAll('.scroll-reveal');

            const observerOptions = {
                root: null, // El viewport es el elemento ra√≠z
                rootMargin: '0px',
                threshold: 0.2 // Se activa cuando el 20% del elemento es visible
            };

            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Si el elemento es visible, a√±ade la clase 'visible'
                        entry.target.classList.add('visible');
                        // Deja de observar el elemento una vez que se ha animado
                        observer.unobserve(entry.target);
                    }
                });
            }, observerOptions);

            // Empezar a observar todos los elementos
            scrollRevealElements.forEach(el => {
                observer.observe(el);
            });


        });
    </script>
</body>
</html>
