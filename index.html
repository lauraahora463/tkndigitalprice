<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Trading TKN y An√°lisis T√©cnico</title>

    <!-- Tailwind CSS y Fuente Inter -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">

    <style>
        /* Estilos Base: Fondo oscuro y fuente */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117;
            color: #e6e6e6;
            min-height: 100vh;
        }

        /* Contenedor de la gr√°fica y Card de Contenido */
        #chartContainer {
            height: 60vh;
            max-width: 1200px;
            margin: 0 auto;
            border-radius: 1rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
            background-color: #161b22;
        }

        #cryptoChart {
            display: block;
            background-color: transparent;
        }

        .content-card {
            background-color: #161b22;
            border: 1px solid #2d333b;
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            /* Necesario para el efecto de despliegue */
        }

        /* Estilo para el input y el bot√≥n de despliegue del acorde√≥n */
        .accordion-content {
            max-height: 0;
            opacity: 0;
            transition: max-height 0.5s ease-in-out, opacity 0.4s ease-in-out, padding 0.5s;
            overflow: hidden;
            padding-top: 0;
        }

        .accordion-content.open {
            max-height: 500px;
            /* Suficientemente grande para el contenido */
            opacity: 1;
            padding-top: 1rem;
        }

        /* Estilo para los formularios y botones de Auth */
        .auth-input {
            background-color: #2d333b;
            border: 1px solid #484f58;
            color: #e6e6e6;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            outline: none;
            transition: border-color 0.2s;
        }

        .auth-input:focus {
            border-color: #38bdf8;
            /* Tailwind sky-400 */
        }

        .auth-btn {
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-weight: 600;
            transition: background-color 0.2s, transform 0.1s;
        }

        .auth-btn:hover {
            transform: translateY(-1px);
        }

        /* --- Estilos para la Animaci√≥n de Scroll (Scroll Reveal) --- */
        .scroll-reveal {
            opacity: 0;
            transform: translateX(-100px);
            /* Oculto a la izquierda por defecto */
            transition: opacity 1s ease-out, transform 1s ease-out;
            will-change: opacity, transform;
        }

        .scroll-reveal.visible {
            opacity: 1;
            transform: translateX(0);
        }

        /* Para que el segundo elemento entre desde la derecha (opcional pero elegante) */
        .scroll-reveal:nth-child(even) {
            transform: translateX(100px);
            /* Oculto a la derecha */
        }

        .scroll-reveal:nth-child(even).visible {
            transform: translateX(0);
        }

        /* Responsividad */
        @media (max-width: 768px) {
            #chartContainer {
                height: 45vh;
            }
        }
    </style>
</head>

<body class="p-4 flex flex-col items-center">

    <!-- SECCI√ìN 1: ENCABEZADO Y TCKER -->
    <header class="w-full max-w-7xl text-center py-4 mb-4">
        <h1 class="text-4xl font-extrabold text-teal-400">Herramientas fundamentales de arbitraje</h1>
    </header>

    <!-- CONTENEDOR PRINCIPAL: PANEL DE PRECIOS Y AUTENTICACI√ìN -->
    <div class="w-full max-w-7xl flex flex-col md:flex-row justify-between gap-4 mb-6">

        <!-- PANEL DE PRECIO PRINCIPAL -->
        <div id="price-panel" class="w-full md:w-2/3 bg-[#161b22] p-4 rounded-lg shadow-xl border border-teal-500/50">

            <!-- Ticker Principal -->
            <div class="p-2">
                <span class="text-xl md:text-2xl font-bold text-gray-300">Criptomoneda (ARS/USD)</span>
                <div class="flex items-end mt-1">
                    <span id="current-price"
                        class="text-4xl md:text-5xl font-extrabold text-green-400 mr-4">$0.00</span>
                    <span id="price-change" class="text-lg md:text-xl font-semibold text-green-500">
                        <span id="change-icon">‚ñ≤</span> <span id="change-value">0.00%</span>
                    </span>
                </div>
            </div>

            <!-- Cotizaciones en Tiempo Real -->
            <div id="realtime-rates" class="mt-4 border-t border-gray-700 pt-3">
                <h3 class="text-lg font-bold text-teal-300 mb-2 flex items-center">
                    <svg class="w-5 h-5 mr-2 text-teal-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                            d="M4 6h16M4 12h16M4 18h16" />
                    </svg>
                    Cotizaciones en Tiempo Real
                </h3>
                <div id="rates-list" class="text-sm text-gray-300 space-y-1">
                    <p>üíµ D√≥lar Blue: <span id="rate-blue" class="font-semibold text-green-400">Cargando...</span></p>
                    <p>üè¶ D√≥lar Oficial: <span id="rate-oficial" class="font-semibold text-green-400">Cargando...</span>
                    </p>
                    <p>üìä D√≥lar MEP: <span id="rate-mep" class="font-semibold text-green-400">Cargando...</span></p>
                    <p>üíº D√≥lar CCL: <span id="rate-ccl" class="font-semibold text-green-400">Cargando...</span></p>
                </div>
            </div>
        </div>

        <!-- SCRIPT DE COTIZACIONES -->
        <script>
            // --- COTIZACIONES REALES DE D√ìLAR ARGENTINO ---
            async function fetchDolarRates() {
                try {
                    const res = await fetch("https://dolarapi.com/v1/dolares");
                    const data = await res.json();

                    const blue = data.find(d => d.nombre === "Blue");
                    const oficial = data.find(d => d.nombre === "Oficial");
                    const mep = data.find(d => d.nombre === "Bolsa");
                    const ccl = data.find(d => d.nombre === "Contado con liquidaci√≥n");

                    document.getElementById("rate-blue").textContent = blue?.venta ? `$${blue.venta.toFixed(2)}` : "N/D";
                    document.getElementById("rate-oficial").textContent = oficial?.venta ? `$${oficial.venta.toFixed(2)}` : "N/D";
                    document.getElementById("rate-mep").textContent = mep?.venta ? `$${mep.venta.toFixed(2)}` : "N/D";
                    document.getElementById("rate-ccl").textContent = ccl?.venta ? `$${ccl.venta.toFixed(2)}` : "N/D";
                } catch (err) {
                    console.error("Error obteniendo cotizaciones:", err);
                    document.getElementById("rates-list").innerHTML = `<p class="text-red-400">‚ùå Error al cargar cotizaciones</p>`;
                }
            }

            // Actualiza cada 5 minutos
            fetchDolarRates();
            setInterval(fetchDolarRates, 300000);
        </script>

        <!-- Panel de Autenticaci√≥n (Derecha/Abajo) -->
        <div id="auth-panel"
            class="w-full md:w-1/3 bg-[#161b22] p-4 rounded-lg shadow-xl border border-purple-500/50 flex flex-col justify-center">
            <!-- Contenido de Autenticaci√≥n se renderizar√° aqu√≠ -->
        </div>

    </div>

    <!-- SECCI√ìN 2: GR√ÅFICA INTERACTIVA -->
    <div id="chartContainer" class="p-2 mb-10 w-full max-w-7xl">
        <canvas id="cryptoChart"></canvas>
    </div>

    <!-- SECCI√ìN 3: HERRAMIENTAS DE AN√ÅLISIS T√âCNICO (Acorde√≥n y Scroll Reveal) -->
    <main class="w-full max-w-7xl px-4 md:px-0">
        <h2 class="text-3xl font-bold text-purple-400 mb-6 border-b border-gray-700 pb-2">Herramientas Clave de An√°lisis
            Gr√°fico</h2>

        <div class="grid md:grid-cols-2 gap-6 mb-12">

            <!-- Herramienta 1: Diferencial de Tipo de Cambio -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 7h8m0 0v8m0-8l-8 8-4-4-6 6"></path>
                        </svg>
                        Diferencial de Tipo de Cambio (Blue, MEP, CCL)
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0"
                        data-arrow-icon="ma" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>
                <div class="accordion-content" data-content="ma">
                    <p class="text-gray-400 text-sm mt-2">El diferencial entre los distintos tipos de cambio (oficial,
                        blue, MEP, CCL)
                        es la base del arbitraje cambiario en Argentina. Permite detectar oportunidades de ganancia al
                        operar entre
                        mercados con brechas significativas.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li><strong>Brecha Cambiaria:</strong> Diferencia porcentual entre cotizaciones paralelas y
                            oficiales.</li>
                        <li><strong>Indicador Clave:</strong> Brechas superiores al 10% pueden habilitar operaciones de
                            arbitraje.</li>
                        <li><strong>Uso T√©cnico:</strong> Monitorear en tiempo real cotizaciones de fuentes confiables
                            (BCRA, d√≥lar MEP,
                            CCL, Blue).</li>
                    </ul>
                </div>
            </div>

            <!-- Herramienta 2: Spread entre Exchanges o Brokers -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-red-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0h2m4 0V5a2 2 0 00-2-2h-2a2 2 0 00-2 2v14m0 0h2m2-14h2m-2 2h2m-2 4h2m-2 4h2">
                            </path>
                        </svg>
                        Spread entre Exchanges o Brokers
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0"
                        data-arrow-icon="rsi" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>
                <div class="accordion-content" data-content="rsi">
                    <p class="text-gray-400 text-sm mt-2">El spread es la diferencia entre el precio de compra y venta
                        de USD entre
                        plataformas. En arbitraje, un spread amplio entre exchanges o brokers puede aprovecharse
                        comprando en el m√°s
                        barato y vendiendo en el m√°s caro.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li><strong>Spread Efectivo:</strong> (Precio venta - Precio compra) / Precio venta √ó 100.</li>
                        <li><strong>Plataformas Comunes:</strong> Binance P2P, Lemon, Belo, Buenbit, Satoshitango, Cocos
                            Capital.</li>
                        <li><strong>Estrategia:</strong> Automatizar la detecci√≥n con APIs y bots para ejecutar
                            operaciones en tiempo
                            real.</li>
                    </ul>
                </div>
            </div>

            <!-- Herramienta 3: Monitoreo de Liquidez -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 12l2 2 4-4m5 4h.01M9 16h.01M19 16h.01M9 20h.01"></path>
                        </svg>
                        Monitoreo de Liquidez y Profundidad de Mercado
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0"
                        data-arrow-icon="bb" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>
                <div class="accordion-content" data-content="bb">
                    <p class="text-gray-400 text-sm mt-2">La liquidez determina qu√© tan r√°pido se puede ejecutar una
                        operaci√≥n sin
                        afectar el precio. En arbitraje, mercados con baja liquidez pueden generar slippage y reducir la
                        rentabilidad.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li><strong>Orden Book:</strong> Analizar profundidad y tama√±o de √≥rdenes en tiempo real.</li>
                        <li><strong>Slippage:</strong> Diferencia entre el precio esperado y el ejecutado por baja
                            liquidez.</li>
                        <li><strong>Herramientas:</strong> APIs de Binance, Cocos, Bitso o Rava para lectura directa de
                            volumen y
                            profundidad.</li>
                    </ul>
                </div>
            </div>

            <!-- Herramienta 4: Bots y Automatizaci√≥n de Arbitraje -->
            <div class="content-card scroll-reveal">
                <div class="flex items-center justify-between cursor-pointer" onclick="toggleAccordion(this)">
                    <h3 class="text-xl font-bold text-gray-200 flex items-center">
                        <svg class="w-6 h-6 mr-2 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                            xmlns="http://www.w3.org/2000/svg">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M7 12l2 2 4-4 2 2 4-4m-12 3v3m0 3h.01M16 8h.01M9 8h.01M7 16h.01M16 16h.01"></path>
                        </svg>
                        Bots y Automatizaci√≥n de Arbitraje
                    </h3>
                    <svg class="w-5 h-5 text-gray-400 transition-transform duration-500 transform rotate-0"
                        data-arrow-icon="macd" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                        xmlns="http://www.w3.org/2000/svg">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
                    </svg>
                </div>
                <div class="accordion-content" data-content="macd">
                    <p class="text-gray-400 text-sm mt-2">Los bots de arbitraje ejecutan operaciones autom√°ticas
                        aprovechando brechas de
                        precio entre diferentes mercados o tipos de cambio. Permiten reaccionar en milisegundos, algo
                        imposible
                        manualmente.</p>
                    <ul class="list-disc ml-5 mt-3 text-sm text-gray-500 space-y-1">
                        <li><strong>API Automation:</strong> Integraci√≥n con APIs de exchange para lectura y ejecuci√≥n
                            simult√°nea.</li>
                        <li><strong>Delay Control:</strong> Ajustar tiempos de reacci√≥n para evitar bloqueos o errores
                            por latencia.</li>
                        <li><strong>Seguridad:</strong> Encriptar claves API y monitorear ejecuci√≥n con logs y
                            validaciones IP.</li>
                    </ul>
                </div>
            </div>


        </div>
    </main>

    <!-- SECCI√ìN 4: C√ìDIGO JAVASCRIPT -->
    <script type="text/javascript">
        document.addEventListener('DOMContentLoaded', () => {
            // --- CONSTANTES DEL DOM Y CONFIGURACI√ìN ---
            const chartCanvas = document.getElementById('cryptoChart');
            const chartCtx = chartCanvas.getContext('2d');
            const chartContainerElement = document.getElementById('chartContainer');
            const currentPriceElement = document.getElementById('current-price');
            const priceChangeElement = document.getElementById('change-value');
            const changeIconElement = document.getElementById('change-icon');
            const authPanel = document.getElementById('auth-panel');

            // --- CONFIGURACI√ìN DE LA SIMULACI√ìN DE TRADING ---
            const CANDLE_COUNT = 60;
            const PRICE_BASE = 85.00;
            const PRICE_VOLATILITY = 5.00;
            const PRICE_DECAY = 0.9995;
            let lastClosePrice = PRICE_BASE;
            let candles = [];

            // --- L√ìGICA DE AUTENTICACI√ìN ---

            const STORAGE_KEY = 'tkn_current_user';
            let currentUser = null;

            /**
             * Intenta cargar el usuario de localStorage al inicio.
             */
            function loadUserFromStorage() {
                const userData = localStorage.getItem(STORAGE_KEY);
                if (userData) {
                    try {
                        currentUser = JSON.parse(userData);
                    } catch (e) {
                        console.error("Error al parsear datos de usuario de localStorage", e);
                        currentUser = null;
                        localStorage.removeItem(STORAGE_KEY);
                    }
                }
            }

            /**
             * Guarda la informaci√≥n del usuario en localStorage.
             * Ahora guarda email, tel√©fono y CONTRASE√ëA.
             * @param {Object} user - Objeto con los datos del usuario (email, phone, password, etc.)
             */
            function saveUserToStorage(user) {
                // !!! ADVERTENCIA DE SEGURIDAD CR√çTICA !!!
                // En una aplicaci√≥n real, NUNCA se debe guardar la contrase√±a (user.password) 
                // en texto plano en localStorage, ni siquiera para "comunicaci√≥n". 
                currentUser = {
                    email: user.email,
                    phone: user.phone || null,
                    password: user.password || null // Guardando la contrase√±a seg√∫n solicitud.
                };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(currentUser));
                renderAuthPanel();
            }

            /**
             * Cierra la sesi√≥n y elimina el usuario de localStorage.
             */
            function logout() {
                currentUser = null;
                localStorage.removeItem(STORAGE_KEY);
                renderAuthPanel();
            }

            /**
             * Simula el registro de un nuevo usuario.
             */
            function handleRegister(email, phone, password) {
                // Validaci√≥n: email y contrase√±a (m√≠nimo 6) obligatorios. Tel√©fono es opcional.
                if (!email || password.length < 6) {
                    displayMessage('El email y la contrase√±a (m√≠nimo 6 caracteres) son obligatorios.', 'red');
                    return;
                }
                if (phone && isNaN(phone.replace(/\s/g, ''))) {
                    displayMessage('El campo de tel√©fono debe ser un n√∫mero v√°lido.', 'red');
                    return;
                }

                // Simulaci√≥n de que el registro es exitoso
                displayMessage(`¬°Registro exitoso para ${email}! Iniciando sesi√≥n...`, 'green');
                // Se guardan email, phone Y password.
                saveUserToStorage({ email, phone, password });
            }

            /**
             * Simula el inicio de sesi√≥n.
             */
            function handleLogin(email, password) {
                // Validaci√≥n simple
                if (!email || !password) {
                    displayMessage('Introduce tu email y contrase√±a.', 'red');
                    return;
                }

                // Simulaci√≥n: cualquier email con una contrase√±a de 6+ caracteres es v√°lido
                if (password.length >= 6) {
                    displayMessage(`¬°Bienvenido de nuevo, ${email}!`, 'green');
                    // Al iniciar sesi√≥n, solo necesitamos el email, ya que el resto de datos 
                    // (tel√©fono/contrase√±a) ya est√°n en localStorage si se registraron previamente.
                    saveUserToStorage({ email });
                } else {
                    displayMessage('Credenciales incorrectas (Simulaci√≥n).', 'red');
                }
            }

            /**
             * Muestra un mensaje temporal en el panel de autenticaci√≥n.
             */
            function displayMessage(message, color) {
                const messageBox = authPanel.querySelector('#auth-message');
                if (messageBox) {
                    // Clases hardcodeadas para Tailwind din√°mico
                    const bgColor = color === 'red' ? 'bg-red-600/80' : 'bg-green-600/80';
                    messageBox.className = `p-2 mb-3 text-sm rounded-lg text-white ${bgColor}`;
                    messageBox.textContent = message;
                    setTimeout(() => {
                        messageBox.textContent = '';
                        messageBox.className = 'mb-3';
                    }, 4000);
                }
            }

            /**
             * Renderiza el formulario de Login/Register o la info del usuario.
             */
            function renderAuthPanel(mode = 'login') {
                authPanel.innerHTML = `<div id="auth-message" class="mb-3"></div>`;

                if (currentUser) {
                    // Estado Logueado
                    // Muestra el email, tel√©fono y el recordatorio de la contrase√±a guardada
                    const phoneDisplay = currentUser.phone ? `<p class="text-sm text-gray-400 mb-2">üìû ${currentUser.phone}</p>` : '';
                    const passwordWarning = currentUser.password ? `<p class="text-xs text-red-400 italic">‚ö†Ô∏è Contrase√±a guardada: ${currentUser.password}</p>` : '';

                    authPanel.innerHTML += `
                        <div class="text-center">
                            <h3 class="text-xl font-bold text-teal-400">Bienvenido</h3>
                            <p class="text-sm text-gray-300 truncate mb-1">üìß ${currentUser.email}</p>
                            ${phoneDisplay}
                            ${passwordWarning}
                            <button id="logout-btn" class="auth-btn bg-red-600 hover:bg-red-700 text-white w-full mt-4">Cerrar Sesi√≥n</button>
                        </div>
                    `;
                    document.getElementById('logout-btn').addEventListener('click', logout);
                } else {
                    // Estado Deslogueado (Login/Register)
                    let phoneInputHTML = '';
                    if (mode === 'register') {
                        phoneInputHTML = `<input type="tel" id="auth-phone" class="auth-input" placeholder="Tel√©fono (Opcional)">`;
                    }

                    const formHTML = `
                        <h3 class="text-xl font-bold text-purple-400 mb-4">${mode === 'login' ? 'Iniciar Sesi√≥n' : 'Registro'}</h3>
                        <form id="auth-form" class="flex flex-col space-y-3">
                            <input type="email" id="auth-email" class="auth-input" placeholder="Email" required>
                            ${phoneInputHTML} <!-- Campo de tel√©fono -->
                            <input type="password" id="auth-password" class="auth-input" placeholder="Contrase√±a (m√≠n. 6)" required>
                            
                            <button type="submit" class="auth-btn bg-indigo-600 hover:bg-indigo-700 text-white">
                                ${mode === 'login' ? 'Acceder' : 'Registrarse'}
                            </button>
                        </form>
                        <p class="text-center text-xs mt-3 text-gray-400">
                            ${mode === 'login'
                            ? '¬øNo tienes cuenta? <a href="#" id="toggle-register" class="text-purple-400 hover:text-purple-300">Reg√≠strate</a>'
                            : '¬øYa tienes cuenta? <a href="#" id="toggle-login" class="text-purple-400 hover:text-purple-300">Inicia Sesi√≥n</a>'
                        }
                        </p>
                    `;
                    authPanel.innerHTML += formHTML;

                    // Manejo del env√≠o del formulario
                    document.getElementById('auth-form').addEventListener('submit', (e) => {
                        e.preventDefault();
                        const email = document.getElementById('auth-email').value;
                        const password = document.getElementById('auth-password').value;

                        if (mode === 'register') {
                            const phone = document.getElementById('auth-phone').value;
                            handleRegister(email, phone, password);
                        } else {
                            handleLogin(email, password);
                        }
                    });

                    // Manejo del cambio de modo
                    if (document.getElementById('toggle-register')) {
                        document.getElementById('toggle-register').addEventListener('click', (e) => {
                            e.preventDefault();
                            renderAuthPanel('register');
                        });
                    }
                    if (document.getElementById('toggle-login')) {
                        document.getElementById('toggle-login').addEventListener('click', (e) => {
                            e.preventDefault();
                            renderAuthPanel('login');
                        });
                    }
                }
            }

            // Inicializar la autenticaci√≥n
            loadUserFromStorage();
            renderAuthPanel(currentUser ? 'logged' : 'login');


            // --- FIN DE L√ìGICA DE AUTENTICACI√ìN ---


            // --- L√ìGICA DE LA GR√ÅFICA ---

            /**
             * Genera una nueva vela (OHLC) bas√°ndose en el precio de cierre anterior.
             */
            function generateNewCandle() {
                const open = lastClosePrice;
                let close = open + (Math.random() * PRICE_VOLATILITY * 2 - PRICE_VOLATILITY) * (1 + (Math.random() - 0.5) * 0.1);

                const driftFactor = 1 - (close - PRICE_BASE) / (PRICE_BASE * 10) * (1 - PRICE_DECAY);
                close *= driftFactor;

                const bodyMin = Math.min(open, close);
                const bodyMax = Math.max(open, close);

                const high = bodyMax + Math.random() * PRICE_VOLATILITY * 0.2;
                const low = bodyMin - Math.random() * PRICE_VOLATILITY * 0.2;

                const finalLow = Math.min(low, bodyMin);
                const finalHigh = Math.max(high, bodyMax);

                lastClosePrice = close;

                return { open, high: finalHigh, low: finalLow, close, timestamp: Date.now() };
            }

            /**
             * Genera los datos iniciales de las velas.
             */
            function initializeCandles() {
                for (let i = 0; i < CANDLE_COUNT; i++) {
                    const newCandle = generateNewCandle();
                    candles.push(newCandle);
                    lastClosePrice = newCandle.close;
                }
                lastClosePrice = candles[candles.length - 1].close;
            }

            initializeCandles();


            /**
             * Normaliza las coordenadas del precio a la posici√≥n Y del canvas.
             */
            function getY(price, minPrice, maxPrice, height) {
                const priceRange = maxPrice - minPrice;
                const normalizedY = 1 - ((price - minPrice) / priceRange);
                return normalizedY * height;
            }

            /**
             * Dibuja la gr√°fica de velas en el canvas.
             */
            function drawChart() {
                const width = chartCanvas.width;
                const height = chartCanvas.height;

                chartCtx.clearRect(0, 0, width, height);

                // Rango de precios y buffer
                const prices = candles.flatMap(c => [c.high, c.low]);
                if (prices.length === 0) return;

                const minPrice = Math.min(...prices) * 0.9999;
                const maxPrice = Math.max(...prices) * 1.0001;
                const priceRange = maxPrice - minPrice;

                const candleSpacing = width / CANDLE_COUNT;
                const currentCandleWidth = candleSpacing * 0.7;

                // 1. Dibujar Cuadr√≠cula
                chartCtx.strokeStyle = '#2d333b';
                chartCtx.lineWidth = 1;
                const gridLines = 5;
                for (let i = 0; i < gridLines; i++) {
                    const y = (height / (gridLines - 1)) * i;
                    chartCtx.beginPath();
                    chartCtx.moveTo(0, y);
                    chartCtx.lineTo(width, y);
                    chartCtx.stroke();
                }

                // 2. Dibujar Velas (Candlesticks)
                candles.forEach((candle, index) => {
                    const x = index * candleSpacing + (candleSpacing - currentCandleWidth) / 2;

                    const yOpen = getY(candle.open, minPrice, maxPrice, height);
                    const yClose = getY(candle.close, minPrice, maxPrice, height);
                    const yHigh = getY(candle.high, minPrice, maxPrice, height);
                    const yLow = getY(candle.low, minPrice, maxPrice, height);

                    const isBullish = candle.close > candle.open;
                    const color = isBullish ? '#10b981' : '#ef4444';

                    chartCtx.fillStyle = color;
                    chartCtx.strokeStyle = color;
                    chartCtx.lineWidth = 1;

                    // Dibujar la Mecha
                    chartCtx.beginPath();
                    chartCtx.moveTo(x + currentCandleWidth / 2, yHigh);
                    chartCtx.lineTo(x + currentCandleWidth / 2, yLow);
                    chartCtx.stroke();

                    // Dibujar el Cuerpo
                    const bodyTop = Math.min(yOpen, yClose);
                    const bodyHeight = Math.abs(yOpen - yClose);
                    const actualBodyHeight = Math.max(1, bodyHeight);
                    const actualBodyTop = bodyHeight < 1 ? (isBullish ? yClose - 0.5 : yOpen - 0.5) : bodyTop;

                    chartCtx.fillRect(x, actualBodyTop, currentCandleWidth, actualBodyHeight);
                });

                // 3. Dibujar Eje de Precios (Derecha)
                chartCtx.font = '10px Inter';
                chartCtx.fillStyle = '#e6e6e6';

                for (let i = 0; i < gridLines; i++) {
                    const y = (height / (gridLines - 1)) * i;
                    const price = maxPrice - (priceRange / (gridLines - 1)) * i;
                    const formattedPrice = '$' + price.toFixed(2);

                    chartCtx.textAlign = 'left';
                    chartCtx.fillText(formattedPrice, width + 5, y + 3);

                    chartCtx.beginPath();
                    chartCtx.moveTo(width, y);
                    chartCtx.lineTo(width - 5, y);
                    chartCtx.stroke();
                }

                // 4. Dibujar Precio Actual (L√≠nea de Close)
                const lastY = getY(lastClosePrice, minPrice, maxPrice, height);
                const lastClosePriceFormatted = lastClosePrice.toFixed(2);

                chartCtx.strokeStyle = '#e6e6e6';
                chartCtx.lineWidth = 2;
                chartCtx.setLineDash([5, 5]);
                chartCtx.beginPath();
                chartCtx.moveTo(0, lastY);
                chartCtx.lineTo(width, lastY);
                chartCtx.stroke();
                chartCtx.setLineDash([]);

                chartCtx.fillStyle = '#e6e6e6';
                chartCtx.textAlign = 'right';
                chartCtx.fillRect(width, lastY - 8, 70, 16);
                chartCtx.fillStyle = '#161b22';
                chartCtx.fillText('$' + lastClosePriceFormatted, width + 65, lastY + 4);

                updatePricePanel(candles);
            }

            /**
             * Actualiza el panel de precios principal con la √∫ltima vela.
             */
            function updatePricePanel(currentCandles) {
                if (currentCandles.length < 2) return;

                const lastCandle = currentCandles[currentCandles.length - 1];
                const prevCandle = currentCandles[currentCandles.length - 2];

                const currentPrice = lastCandle.close;
                const change = currentPrice - prevCandle.close;
                const percentageChange = (change / prevCandle.close) * 100;

                const isPositive = change >= 0;
                const priceClass = isPositive ? 'text-green-400' : 'text-red-400';
                const changeClass = isPositive ? 'text-green-500' : 'text-red-500';
                const changeIcon = isPositive ? '‚ñ≤' : '‚ñº';

                currentPriceElement.textContent = '$' + currentPrice.toFixed(2);
                currentPriceElement.className = `text-4xl md:text-5xl font-extrabold mr-4 ${priceClass}`;

                priceChangeElement.textContent = `${percentageChange.toFixed(2)}%`;
                priceChangeElement.parentElement.className = `text-lg md:text-xl font-semibold ${changeClass}`;

                changeIconElement.textContent = changeIcon;
            }


            /**
             * Funci√≥n para actualizar la gr√°fica con nuevos datos (cada segundo).
             */
            function updateChartData() {
                candles.shift();
                candles.push(generateNewCandle());
                drawChart();
            }

            // --- L√ìGICA DE REDIMENSIONAMIENTO RESPONSIVO ---
            const chartResizeObserver = new ResizeObserver(entries => {
                const containerEntry = entries.find(entry => entry.target === chartContainerElement);
                if (!containerEntry) return;

                const newRect = containerEntry.contentRect;
                // El ancho debe ser todo el contenedor menos el espacio para las etiquetas de precio
                chartCanvas.width = newRect.width - 75;
                chartCanvas.height = newRect.height;

                drawChart();
            });

            chartResizeObserver.observe(chartContainerElement);

            // Inicio del loop de simulaci√≥n
            drawChart();
            setInterval(updateChartData, 1000);


            // --- L√ìGICA DE ACORDE√ìN (Bot√≥n Desplegable) ---

            /**
             * Alterna la visibilidad y aplica la transici√≥n del contenido del acorde√≥n.
             * @param {HTMLElement} headerElement - El elemento que contiene el t√≠tulo (donde se hizo click).
             */
            window.toggleAccordion = function (headerElement) {
                const parentCard = headerElement.closest('.content-card');
                const content = parentCard.querySelector('.accordion-content');
                const arrowIcon = headerElement.querySelector('[data-arrow-icon]');

                // Alternar la clase 'open' para activar las transiciones CSS
                content.classList.toggle('open');

                // Rotar el icono de flecha
                if (content.classList.contains('open')) {
                    arrowIcon.classList.remove('rotate-0');
                    arrowIcon.classList.add('rotate-180');
                } else {
                    arrowIcon.classList.remove('rotate-180');
                    arrowIcon.classList.add('rotate-0');
                }
            };


            // --- L√ìGICA DE ANIMACI√ìN AL HACER SCROLL (Intersection Observer) ---

            const scrollRevealElements = document.querySelectorAll('.scroll-reveal');

            const observerOptions = {
                root: null, // El viewport es el elemento ra√≠z
                rootMargin: '0px',
                threshold: 0.2 // Se activa cuando el 20% del elemento es visible
            };

            const observer = new IntersectionObserver((entries, observer) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        // Si el elemento es visible, a√±ade la clase 'visible'
                        entry.target.classList.add('visible');
                        // Deja de observar el elemento una vez que se ha animado
                        observer.unobserve(entry.target);
                    }
                });
            }, observerOptions);

            // Empezar a observar todos los elementos
            scrollRevealElements.forEach(el => {
                observer.observe(el);
            });


        });
    </script>
</body>

</html>